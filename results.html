<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Результаты PDQ-4</title>
  <link rel="stylesheet" href="css/style.css" />
  <style>
    body {
      background-color: #f7f7f7;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    .container {
      background: #fff;
      border-radius: 1.5rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
      text-align: center;
      padding: 2rem;
    }
    canvas {
      margin-top: 1rem;
    }
    h1 {
      font-weight: 700;
      margin-bottom: 1rem;
    }
    .result-btn {
      background-color: #007aff;
      color: white;
      border: none;
      border-radius: 0.8rem;
      padding: 0.7rem 1.5rem;
      margin-top: 1.5rem;
      cursor: pointer;
      font-size: 1.2rem;
    }
  </style>
</head>
<body>
  <main class="container">
    <h1>Ваш профиль PDQ-4</h1>
    <canvas id="wheel" width="500" height="500"></canvas>
    <button class="result-btn" onclick="window.location.href='index.html'">На главную</button>
  </main>

  <script type="module">
    import { calculateResults } from './js/calculateResults.mjs';

    const answers = JSON.parse(localStorage.getItem('pdqResultsTemp'));
    if (!answers) window.location.href = 'index.html';

    async function drawWheel() {
      let results = {};
      for (let i = 0; i < 10; i++) {
        results = calculateResults(answers);
        if (Object.keys(results).length > 0) break;
        await new Promise(r => setTimeout(r, 200));
      }
      if (!Object.keys(results).length) {
        alert('Ошибка загрузки шкал');
        return;
      }

      const canvas = document.getElementById('wheel');
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 180;

      const labels = Object.keys(results);
      const step = (2 * Math.PI) / labels.length;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = '14px -apple-system, BlinkMacSystemFont, Roboto, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      labels.forEach((label, i) => {
        const { score, threshold, color } = results[label];
        const angleStart = i * step - Math.PI / 2;
        const angleEnd = angleStart + step;

        // Заполненный сектор (в зависимости от выраженности)
        const fillRadius = (radius * Math.min(score, threshold)) / threshold;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, fillRadius, angleStart, angleEnd);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();

        // Контур сектора
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, angleStart, angleEnd);
        ctx.closePath();
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Подписи снаружи
        const labelAngle = angleStart + step / 2;
        const labelX = centerX + (radius + 30) * Math.cos(labelAngle);
        const labelY = centerY + (radius + 30) * Math.sin(labelAngle);
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px -apple-system';
        ctx.fillText(label, labelX, labelY);

        // Цифра (количество баллов) в секторе
        const valueX = centerX + (fillRadius / 1.8) * Math.cos(labelAngle);
        const valueY = centerY + (fillRadius / 1.8) * Math.sin(labelAngle);
        ctx.fillStyle = '#000';
        ctx.font = '14px -apple-system';
        ctx.fillText(score.toString(), valueX, valueY);
      });

      // Круговая сетка
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 0.5;
      for (let r = radius / 5; r <= radius; r += radius / 5) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
        ctx.stroke();
      }
    }

    drawWheel();
  </script>
</body>
</html>
